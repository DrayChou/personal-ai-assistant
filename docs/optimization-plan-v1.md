# Personal AI Assistant ä¼˜åŒ–æ–¹æ¡ˆ v1.0

## æ‰§è¡Œæ‘˜è¦

åŸºäºä¸ claw0/OpenClaw æ¶æ„çš„æ·±å…¥å¯¹æ¯”åˆ†æï¼Œå½“å‰ç³»ç»Ÿåœ¨**æ™ºèƒ½èƒ½åŠ›**ï¼ˆè®°å¿†ã€Agentã€æ„å›¾è¯†åˆ«ï¼‰æ–¹é¢å·²è¶…è¶Š claw0ï¼Œä½†åœ¨**åŸºç¡€è®¾æ–½**ï¼ˆGatewayã€æ¶ˆæ¯é˜Ÿåˆ—ã€å¤šç”¨æˆ·æ”¯æŒï¼‰æ–¹é¢å­˜åœ¨æ˜æ˜¾çŸ­æ¿ã€‚æœ¬æ–¹æ¡ˆæ—¨åœ¨è¡¥é½è¿™äº›çŸ­æ¿ï¼Œæ‰“é€ ä¸€ä¸ªç”Ÿäº§çº§çš„ä¸ªäºº AI åŠ©æ‰‹ã€‚

**å½“å‰çŠ¶æ€è¯„åˆ†ï¼š**
- æ™ºèƒ½èƒ½åŠ›: â­â­â­â­â­ (5/5)
- è°ƒåº¦èƒ½åŠ›: â­â­â­â­â­ (5/5)
- å·¥å…·ç”Ÿæ€: â­â­â­â­â­ (5/5)
- åŸºç¡€è®¾æ–½: â­â­â˜†â˜†â˜† (2/5)
- å¯é æ€§: â­â­â˜†â˜†â˜† (2/5)
- å¤šç”¨æˆ·æ”¯æŒ: â­â˜†â˜†â˜†â˜† (1/5)

**ç›®æ ‡çŠ¶æ€ï¼š**
- åŸºç¡€è®¾æ–½: â­â­â­â­â­ (5/5)
- å¯é æ€§: â­â­â­â­â­ (5/5)

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šç°çŠ¶è¯Šæ–­

### 1.1 å½“å‰ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å½“å‰ç³»ç»Ÿæ¶æ„                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  Personality â”‚    â”‚   Memory     â”‚    â”‚    Task      â”‚       â”‚
â”‚  â”‚   Manager    â”‚    â”‚   System     â”‚    â”‚   Manager    â”‚       â”‚
â”‚  â”‚  (SOUL.md)   â”‚    â”‚ (L0/L1/L2)   â”‚    â”‚   (JSONL)    â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚         â”‚                   â”‚                   â”‚                â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                             â–¼                                    â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚                    â”‚  SupervisorAgent â”‚                         â”‚
â”‚                    â”‚ (Fast/Single/Multi)â”‚                       â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                             â”‚                                    â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚         â–¼                   â–¼                   â–¼                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚   Intent     â”‚    â”‚   Hybrid     â”‚    â”‚    MCP       â”‚       â”‚
â”‚  â”‚  Classifier  â”‚    â”‚  Scheduler   â”‚    â”‚    Tools     â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                                  â”‚
â”‚  æ¥å£å±‚: CLI only (stdin/stdout)                                 â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒé—®é¢˜æ¸…å•

| ç¼–å· | é—®é¢˜ | ä¸¥é‡ç¨‹åº¦ | å½±å“èŒƒå›´ |
|------|------|---------|----------|
| P0-1 | **æ—  Gateway Server** | ğŸ”´ ä¸¥é‡ | æ— æ³•è¿œç¨‹è®¿é—®ã€æ—  API æ¥å£ |
| P0-2 | **æ—  Delivery Queue** | ğŸ”´ ä¸¥é‡ | æ¶ˆæ¯å¯èƒ½ä¸¢å¤±ã€æ— å¯é æ€§ä¿è¯ |
| P0-3 | **Session ä¸æŒä¹…åŒ–** | ğŸ”´ ä¸¥é‡ | é‡å¯åå¯¹è¯å†å²ä¸¢å¤± |
| P1-1 | **Heartbeat ä¸å®Œæ•´** | ğŸŸ¡ ä¸­ç­‰ | ç¼ºä¹ä¸»åŠ¨è¡Œä¸ºã€æ— äº’æ–¥æœºåˆ¶ |
| P1-2 | **æ— æ¶ˆæ¯è·¯ç”±** | ğŸŸ¡ ä¸­ç­‰ | å•ç”¨æˆ·é™åˆ¶ã€æ— æ³•éš”ç¦» |
| P2-1 | **ä»… CLI é€šé“** | ğŸŸ¢ ä½ | ä½¿ç”¨åœºæ™¯å—é™ |

### 1.3 ä¸ claw0/OpenClaw å·®è·åˆ†æ

```
                    claw0              å½“å‰ç³»ç»Ÿ              å·®è·
                    â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€            â”€â”€â”€â”€
Gateway Server      âœ… å®Œæ•´å®ç°         âŒ ç¼ºå¤±               éœ€æ–°å¢
Delivery Queue      âœ… ç£ç›˜é˜Ÿåˆ—         âŒ ç¼ºå¤±               éœ€æ–°å¢
Session Store       âœ… JSONLè§„èŒƒ        âŒ å†…å­˜å­˜å‚¨            éœ€é‡æ„
Heartbeat           âœ… 6æ­¥æ£€æŸ¥é“¾        âš ï¸ ç®€åŒ–ç‰ˆ             éœ€å¢å¼º
Message Routing     âœ… Bindingæœºåˆ¶      âŒ ç¼ºå¤±               éœ€æ–°å¢
Multi-Channel       âœ… æ’ä»¶æ¥å£         âŒ CLI only           éœ€æ‰©å±•

Memory System       âš ï¸ TF-IDF          âœ… å‘é‡+æ„å›¾æ„ŸçŸ¥        é¢†å…ˆ
Agent Architecture  âš ï¸ ç®€å•å¾ªç¯          âœ… Supervisoråˆ†å±‚     é¢†å…ˆ
Tool Ecosystem      âš ï¸ 4ä¸ªå†…ç½®           âœ… MCPæ— é™æ‰©å±•        é¢†å…ˆ
Intent Recognition  âš ï¸ è§„åˆ™åŒ¹é…          âœ… AI+è¯­ä¹‰è·¯ç”±        é¢†å…ˆ
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šä¼˜åŒ–ç›®æ ‡

### 2.1 æ€»ä½“ç›®æ ‡

æ„å»ºä¸€ä¸ª**ç”Ÿäº§çº§**çš„ä¸ªäºº AI åŠ©æ‰‹ç³»ç»Ÿï¼Œå…·å¤‡ï¼š
1. **å¯é æ€§**ï¼šæ¶ˆæ¯ä¸ä¸¢å¤±ã€æœåŠ¡é«˜å¯ç”¨
2. **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒå¤šé€šé“ã€å¤šç”¨æˆ·ã€å¤š Agent
3. **æ™ºèƒ½åŒ–**ï¼šä¿æŒå¹¶å¢å¼ºç°æœ‰çš„æ™ºèƒ½èƒ½åŠ›ä¼˜åŠ¿
4. **å¯ç»´æŠ¤æ€§**ï¼šæ¸…æ™°çš„æ¶æ„ã€å®Œå–„çš„ç›‘æ§

### 2.2 åˆ†é˜¶æ®µç›®æ ‡

#### é˜¶æ®µä¸€ï¼šåŸºç¡€è®¾æ–½ï¼ˆ4å‘¨ï¼‰
- å®ç° Gateway Server (WebSocket + HTTP)
- å®ç° Delivery Queue (ç£ç›˜æŒä¹…åŒ–)
- é‡æ„ Session Store (JSONL è§„èŒƒ)

#### é˜¶æ®µäºŒï¼šæ™ºèƒ½å¢å¼ºï¼ˆ2å‘¨ï¼‰
- å¢å¼º Heartbeat (6æ­¥æ£€æŸ¥é“¾ + ä¸»åŠ¨è¡Œä¸º)
- å®ç° Message Routing (å¤š Agent æ”¯æŒ)

#### é˜¶æ®µä¸‰ï¼šç”Ÿæ€æ‰©å±•ï¼ˆæŒç»­ï¼‰
- å®ç° Multi-Channel æŠ½è±¡
- æ¥å…¥ Telegramã€Discord ç­‰é€šé“

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šè¯¦ç»†è®¾è®¡æ–¹æ¡ˆ

### 3.1 Gateway Server è®¾è®¡

#### 3.1.1 æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Gateway Server                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚   â”‚   Browser   â”‚  â”‚   Mobile    â”‚  â”‚  Webhook    â”‚            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚          â”‚                â”‚                â”‚                    â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                           â–¼                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚              WebSocket / HTTP Server                   â”‚    â”‚
â”‚   â”‚  (åŸºäº websockets åº“ + aiohttp)                       â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                           â”‚                                     â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚           â–¼               â–¼               â–¼                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚  Connection  â”‚ â”‚  JSON-RPC    â”‚ â”‚   Auth       â”‚          â”‚
â”‚   â”‚   Manager    â”‚ â”‚   Router     â”‚ â”‚ Middleware   â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚          â”‚                â”‚                â”‚                   â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                           â–¼                                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚              Method Handler Registry                   â”‚   â”‚
â”‚   â”‚  chat.send â†’ run_agent()                              â”‚   â”‚
â”‚   â”‚  chat.history â†’ load_history()                        â”‚   â”‚
â”‚   â”‚  channels.status â†’ get_channels()                     â”‚   â”‚
â”‚   â”‚  health â†’ ok                                          â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.1.2 JSON-RPC 2.0 åè®®è§„èŒƒ

**è¯·æ±‚æ ¼å¼ï¼š**
```json
{
    "jsonrpc": "2.0",
    "id": "req-uuid-001",
    "method": "chat.send",
    "params": {
        "text": "ä½ å¥½ï¼Œä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ",
        "session_key": "agent:main:cli:user1",
        "context": {
            "channel": "cli",
            "user_id": "user1"
        }
    }
}
```

**å“åº”æ ¼å¼ï¼š**
```json
{
    "jsonrpc": "2.0",
    "id": "req-uuid-001",
    "result": {
        "message_id": "msg-uuid-001",
        "text": "ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„AIåŠ©æ‰‹...",
        "session_key": "agent:main:cli:user1",
        "timestamp": "2026-02-24T10:30:00Z",
        "tokens_used": 150
    }
}
```

**æµå¼äº‹ä»¶æ ¼å¼ï¼š**
```json
{
    "jsonrpc": "2.0",
    "method": "event",
    "params": {
        "type": "chat.delta",
        "message_id": "msg-uuid-001",
        "delta": "ä½ å¥½",
        "session_key": "agent:main:cli:user1"
    }
}
```

#### 3.1.3 API ç«¯ç‚¹è®¾è®¡

| æ–¹æ³• | åŠŸèƒ½ | è®¤è¯ |
|------|------|------|
| `chat.send` | å‘é€æ¶ˆæ¯å¹¶è·å–å›å¤ | Bearer Token |
| `chat.send_stream` | å‘é€æ¶ˆæ¯ï¼Œæµå¼è¿”å› | Bearer Token |
| `chat.history` | è·å–ä¼šè¯å†å² | Bearer Token |
| `chat.clear` | æ¸…ç©ºä¼šè¯å†å² | Bearer Token |
| `sessions.list` | åˆ—å‡ºæ‰€æœ‰ä¼šè¯ | Bearer Token |
| `sessions.delete` | åˆ é™¤æŒ‡å®šä¼šè¯ | Bearer Token |
| `memory.recall` | æœç´¢è®°å¿† | Bearer Token |
| `tasks.list` | è·å–ä»»åŠ¡åˆ—è¡¨ | Bearer Token |
| `tasks.create` | åˆ›å»ºä»»åŠ¡ | Bearer Token |
| `health` | å¥åº·æ£€æŸ¥ | æ— éœ€è®¤è¯ |

#### 3.1.4 å®ç°ä»£ç ç¤ºä¾‹

```python
# src/gateway/server.py

import asyncio
import json
import logging
from typing import Callable, Dict, Any
import websockets
from websockets.server import WebSocketServerProtocol

logger = logging.getLogger("gateway")


class GatewayServer:
    """
    WebSocket + JSON-RPC 2.0 ç½‘å…³æœåŠ¡å™¨
    """

    def __init__(
        self,
        host: str = "0.0.0.0",
        port: int = 8080,
        auth_token: str | None = None,
        agent=None,  # SupervisorAgent å®ä¾‹
        session_store=None,  # SessionStore å®ä¾‹
    ):
        self.host = host
        self.port = port
        self.auth_token = auth_token
        self.agent = agent
        self.session_store = session_store

        # æ³¨å†Œçš„æ–¹æ³•å¤„ç†å™¨
        self._handlers: Dict[str, Callable] = {
            "chat.send": self._handle_chat_send,
            "chat.send_stream": self._handle_chat_send_stream,
            "chat.history": self._handle_chat_history,
            "sessions.list": self._handle_sessions_list,
            "health": self._handle_health,
        }

        # æ´»è·ƒè¿æ¥
        self._connections: set[WebSocketServerProtocol] = set()

    async def start(self):
        """å¯åŠ¨æœåŠ¡å™¨"""
        logger.info(f"å¯åŠ¨ Gateway Server: ws://{self.host}:{self.port}")
        async with websockets.serve(
            self._handle_connection, self.host, self.port
        ):
            await asyncio.Future()  # æ°¸è¿œè¿è¡Œ

    async def _handle_connection(self, websocket: WebSocketServerProtocol, path: str):
        """å¤„ç†æ–°è¿æ¥"""
        self._connections.add(websocket)
        client_addr = websocket.remote_address
        logger.info(f"æ–°è¿æ¥: {client_addr}")

        try:
            async for message in websocket:
                try:
                    response = await self._process_message(message, websocket)
                    if response:
                        await websocket.send(json.dumps(response))
                except Exception as e:
                    logger.error(f"å¤„ç†æ¶ˆæ¯å¤±è´¥: {e}")
                    await websocket.send(json.dumps(self._error_response(None, -32603, str(e))))
        except websockets.exceptions.ConnectionClosed:
            logger.info(f"è¿æ¥å…³é—­: {client_addr}")
        finally:
            self._connections.discard(websocket)

    async def _process_message(
        self, message: str, websocket: WebSocketServerProtocol
    ) -> dict | None:
        """å¤„ç† JSON-RPC æ¶ˆæ¯"""
        try:
            request = json.loads(message)
        except json.JSONDecodeError:
            return self._error_response(None, -32700, "Parse error")

        # è®¤è¯æ£€æŸ¥
        if self.auth_token and not self._is_authenticated(request):
            return self._error_response(request.get("id"), -32001, "Unauthorized")

        method = request.get("method")
        params = request.get("params", {})
        req_id = request.get("id")

        if method not in self._handlers:
            return self._error_response(req_id, -32601, f"Method not found: {method}")

        try:
            result = await self._handlers[method](params, websocket)
            return {"jsonrpc": "2.0", "id": req_id, "result": result}
        except Exception as e:
            logger.exception(f"Handler {method} failed")
            return self._error_response(req_id, -32603, str(e))

    async def _handle_chat_send(self, params: dict, ws: WebSocketServerProtocol) -> dict:
        """å¤„ç† chat.send"""
        text = params.get("text", "")
        session_key = params.get("session_key", "default")

        # åŠ è½½ä¼šè¯
        session = self.session_store.get_or_create(session_key)

        # è¿è¡Œ Agent
        response_text = ""
        async for output in self.agent.handle(text, session.session_id):
            if isinstance(output, str):
                response_text += output

        # ä¿å­˜ä¼šè¯
        self.session_store.save(session)

        return {
            "message_id": generate_uuid(),
            "text": response_text,
            "session_key": session_key,
            "timestamp": datetime.now().isoformat(),
        }

    async def _handle_chat_send_stream(
        self, params: dict, ws: WebSocketServerProtocol
    ) -> dict:
        """å¤„ç† chat.send_stream (æµå¼è¿”å›)"""
        text = params.get("text", "")
        session_key = params.get("session_key", "default")
        message_id = generate_uuid()

        # å…ˆè¿”å› message_id
        await ws.send(json.dumps({
            "jsonrpc": "2.0",
            "method": "event",
            "params": {
                "type": "chat.start",
                "message_id": message_id,
                "session_key": session_key,
            }
        }))

        # æµå¼è¾“å‡º
        async for chunk in self.agent.handle(text, session_key):
            await ws.send(json.dumps({
                "jsonrpc": "2.0",
                "method": "event",
                "params": {
                    "type": "chat.delta",
                    "message_id": message_id,
                    "delta": chunk,
                    "session_key": session_key,
                }
            }))

        # å‘é€ç»“æŸæ ‡è®°
        await ws.send(json.dumps({
            "jsonrpc": "2.0",
            "method": "event",
            "params": {
                "type": "chat.end",
                "message_id": message_id,
                "session_key": session_key,
            }
        }))

        return {"message_id": message_id, "stream": True}

    async def _handle_health(self, params: dict, ws: WebSocketServerProtocol) -> dict:
        """å¥åº·æ£€æŸ¥"""
        return {
            "status": "ok",
            "version": "1.0.0",
            "timestamp": datetime.now().isoformat(),
        }

    def _error_response(self, req_id: Any, code: int, message: str) -> dict:
        """æ„å»ºé”™è¯¯å“åº”"""
        return {
            "jsonrpc": "2.0",
            "id": req_id,
            "error": {"code": code, "message": message},
        }

    def _is_authenticated(self, request: dict) -> bool:
        """æ£€æŸ¥è®¤è¯"""
        # ä»è¯·æ±‚å¤´æˆ–å‚æ•°ä¸­è·å– token
        # ç®€åŒ–ç‰ˆï¼šæ£€æŸ¥ params ä¸­çš„ token
        params = request.get("params", {})
        token = params.get("token", "")
        return token == self.auth_token
```

---

### 3.2 Delivery Queue è®¾è®¡

#### 3.2.1 æ ¸å¿ƒæœºåˆ¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Delivery Queue                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                      Agent Response                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                            â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  enqueue()                                              â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ ç”Ÿæˆ UUID                                          â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ å†™å…¥ {uuid}.json.tmp (åŸå­å†™å…¥)                     â”‚   â”‚
â”‚  â”‚  â””â”€â”€ rename ä¸º {uuid}.json                              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                            â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Delivery Worker (åå°ä»»åŠ¡)                             â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚  for queue_file in queue_dir:                          â”‚   â”‚
â”‚  â”‚      delivery = load(queue_file)                       â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚      if delivery.next_retry_at <= now:                 â”‚   â”‚
â”‚  â”‚          success = await attempt_delivery(delivery)    â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚          if success:                                   â”‚   â”‚
â”‚  â”‚              ack() â†’ åˆ é™¤æ–‡ä»¶                           â”‚   â”‚
â”‚  â”‚          else:                                         â”‚   â”‚
â”‚  â”‚              fail() â†’ æ›´æ–°é‡è¯•è®¡æ•° + é€€é¿æ—¶é—´           â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚              if retry_count > MAX_RETRIES:             â”‚   â”‚
â”‚  â”‚                  move_to_failed() â†’ failed/ ç›®å½•       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚  é€€é¿æ—¶é—´è¡¨: [5s, 25s, 2m, 10m]                                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.2.2 æ•°æ®ç»“æ„

```python
# src/infra/delivery_queue.py

from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
import json
import uuid
import shutil


@dataclass
class QueuedDelivery:
    """é˜Ÿåˆ—ä¸­çš„æŠ•é€’ä»»åŠ¡"""

    id: str                          # æŠ•é€’ID (UUID)
    channel: str                     # ç›®æ ‡é€šé“ (telegram/discord/cli)
    to: str                          # æ¥æ”¶è€…ID
    text: str                        # æ¶ˆæ¯å†…å®¹
    agent_id: str                    # æ¥æºAgent
    session_key: str                 # ä¼šè¯æ ‡è¯†

    # å…ƒæ•°æ®
    retry_count: int = 0             # é‡è¯•æ¬¡æ•°
    max_retries: int = 5             # æœ€å¤§é‡è¯•æ¬¡æ•°
    last_error: str | None = None    # æœ€åé”™è¯¯ä¿¡æ¯
    enqueued_at: str = ""            # å…¥é˜Ÿæ—¶é—´ (ISOæ ¼å¼)
    next_retry_at: str = ""          # ä¸‹æ¬¡é‡è¯•æ—¶é—´ (ISOæ ¼å¼)

    # é€€é¿æ—¶é—´è¡¨ (ms)
    BACKOFF_MS = [5_000, 25_000, 120_000, 600_000]  # 5s, 25s, 2m, 10m

    def __post_init__(self):
        if not self.enqueued_at:
            self.enqueued_at = datetime.now().isoformat()
        if not self.next_retry_at:
            self.next_retry_at = self.enqueued_at

    def to_dict(self) -> dict:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: dict) -> "QueuedDelivery":
        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})

    def calculate_backoff(self) -> int:
        """è®¡ç®—ä¸‹æ¬¡é‡è¯•çš„é€€é¿æ—¶é—´ (æ¯«ç§’)"""
        idx = min(self.retry_count, len(self.BACKOFF_MS) - 1)
        return self.BACKOFF_MS[idx]


class DeliveryQueue:
    """
    ç£ç›˜æŒä¹…åŒ–çš„æ¶ˆæ¯æŠ•é€’é˜Ÿåˆ—

    ä¿è¯ At-least-once æŠ•é€’è¯­ä¹‰
    """

    def __init__(self, queue_dir: str = "./data/delivery-queue"):
        self.queue_dir = Path(queue_dir)
        self.queue_dir.mkdir(parents=True, exist_ok=True)
        self.failed_dir = self.queue_dir / "failed"
        self.failed_dir.mkdir(exist_ok=True)

        self._running = False
        self._worker_task = None

    async def start(self):
        """å¯åŠ¨æŠ•é€’å·¥ä½œçº¿ç¨‹"""
        self._running = True
        self._worker_task = asyncio.create_task(self._worker_loop())
        logger.info("Delivery Queue å¯åŠ¨")

    async def stop(self):
        """åœæ­¢æŠ•é€’å·¥ä½œçº¿ç¨‹"""
        self._running = False
        if self._worker_task:
            self._worker_task.cancel()
            try:
                await self._worker_task
            except asyncio.CancelledError:
                pass
        logger.info("Delivery Queue åœæ­¢")

    def enqueue(
        self,
        channel: str,
        to: str,
        text: str,
        agent_id: str = "main",
        session_key: str = "",
    ) -> str:
        """
        å°†æ¶ˆæ¯åŠ å…¥æŠ•é€’é˜Ÿåˆ—

        ä½¿ç”¨åŸå­å†™å…¥ä¿è¯æ•°æ®å®‰å…¨ï¼š
        1. å…ˆå†™å…¥ .tmp æ–‡ä»¶
        2. fsync ç¡®ä¿è½ç›˜
        3. rename ä¸ºæ­£å¼æ–‡ä»¶å
        """
        delivery = QueuedDelivery(
            id=str(uuid.uuid4()),
            channel=channel,
            to=to,
            text=text,
            agent_id=agent_id,
            session_key=session_key,
        )

        # åŸå­å†™å…¥
        file_path = self.queue_dir / f"{delivery.id}.json"
        tmp_path = file_path.with_suffix(".tmp")

        try:
            with open(tmp_path, "w", encoding="utf-8") as f:
                json.dump(delivery.to_dict(), f, ensure_ascii=False)
                f.flush()
                os.fsync(f.fileno())

            # åŸå­é‡å‘½å
            os.rename(tmp_path, file_path)
            logger.debug(f"æ¶ˆæ¯å·²å…¥é˜Ÿ: {delivery.id}")
            return delivery.id

        except Exception as e:
            logger.error(f"å…¥é˜Ÿå¤±è´¥: {e}")
            if tmp_path.exists():
                tmp_path.unlink()
            raise

    def ack(self, delivery_id: str):
        """
        ç¡®è®¤æŠ•é€’æˆåŠŸï¼Œåˆ é™¤é˜Ÿåˆ—æ–‡ä»¶
        """
        file_path = self.queue_dir / f"{delivery_id}.json"
        try:
            if file_path.exists():
                file_path.unlink()
                logger.debug(f"æŠ•é€’ç¡®è®¤: {delivery_id}")
        except Exception as e:
            logger.error(f"ç¡®è®¤å¤±è´¥ {delivery_id}: {e}")

    def fail(self, delivery_id: str, error: str):
        """
        æ ‡è®°æŠ•é€’å¤±è´¥ï¼Œæ›´æ–°é‡è¯•è®¡æ•°å’Œé€€é¿æ—¶é—´
        """
        file_path = self.queue_dir / f"{delivery_id}.json"
        if not file_path.exists():
            return

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                delivery = QueuedDelivery.from_dict(json.load(f))

            delivery.retry_count += 1
            delivery.last_error = error

            # è®¡ç®—ä¸‹æ¬¡é‡è¯•æ—¶é—´
            backoff_ms = delivery.calculate_backoff()
            next_retry = datetime.now() + timedelta(milliseconds=backoff_ms)
            delivery.next_retry_at = next_retry.isoformat()

            # å†™å›æ–‡ä»¶
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(delivery.to_dict(), f, ensure_ascii=False)

            logger.debug(f"æŠ•é€’å¤±è´¥: {delivery_id}, é‡è¯• {delivery.retry_count}, ä¸‹æ¬¡ {next_retry}")

        except Exception as e:
            logger.error(f"æ ‡è®°å¤±è´¥å‡ºé”™ {delivery_id}: {e}")

    def move_to_failed(self, delivery_id: str):
        """
        å°†è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°çš„æ¶ˆæ¯ç§»å…¥å¤±è´¥ç›®å½•
        """
        src = self.queue_dir / f"{delivery_id}.json"
        dst = self.failed_dir / f"{delivery_id}.json"

        try:
            if src.exists():
                shutil.move(str(src), str(dst))
                logger.warning(f"æ¶ˆæ¯å·²ç§»å…¥å¤±è´¥é˜Ÿåˆ—: {delivery_id}")
        except Exception as e:
            logger.error(f"ç§»åŠ¨å¤±è´¥ {delivery_id}: {e}")

    def recover_pending(self) -> list[QueuedDelivery]:
        """
        ç³»ç»Ÿå¯åŠ¨æ—¶æ¢å¤æœªå®Œæˆçš„æŠ•é€’ä»»åŠ¡
        """
        pending = []
        for file_path in self.queue_dir.glob("*.json"):
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    delivery = QueuedDelivery.from_dict(json.load(f))
                    pending.append(delivery)
            except Exception as e:
                logger.error(f"æ¢å¤ä»»åŠ¡å¤±è´¥ {file_path}: {e}")

        logger.info(f"æ¢å¤ {len(pending)} ä¸ªå¾…æŠ•é€’ä»»åŠ¡")
        return pending

    async def _worker_loop(self):
        """æŠ•é€’å·¥ä½œçº¿ç¨‹ä¸»å¾ªç¯"""
        while self._running:
            try:
                await self._process_pending()
                await asyncio.sleep(5)  # æ¯5ç§’æ‰«æä¸€æ¬¡
            except Exception as e:
                logger.error(f"å·¥ä½œçº¿ç¨‹é”™è¯¯: {e}")
                await asyncio.sleep(10)

    async def _process_pending(self):
        """å¤„ç†å¾…æŠ•é€’ä»»åŠ¡"""
        now = datetime.now()

        for file_path in self.queue_dir.glob("*.json"):
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    delivery = QueuedDelivery.from_dict(json.load(f))

                # æ£€æŸ¥æ˜¯å¦åˆ°äº†é‡è¯•æ—¶é—´
                next_retry = datetime.fromisoformat(delivery.next_retry_at)
                if next_retry > now:
                    continue

                # æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°
                if delivery.retry_count >= delivery.max_retries:
                    self.move_to_failed(delivery.id)
                    continue

                # å°è¯•æŠ•é€’
                success = await self._attempt_delivery(delivery)

                if success:
                    self.ack(delivery.id)
                else:
                    self.fail(delivery.id, "Delivery failed")

            except Exception as e:
                logger.error(f"å¤„ç†ä»»åŠ¡å¤±è´¥ {file_path}: {e}")

    async def _attempt_delivery(self, delivery: QueuedDelivery) -> bool:
        """
        å®é™…æ‰§è¡ŒæŠ•é€’

        å­ç±»åº”è¯¥é‡å†™æ­¤æ–¹æ³•å®ç°å…·ä½“çš„æŠ•é€’é€»è¾‘
        """
        # é»˜è®¤å®ç°ï¼šè°ƒç”¨æ³¨å†Œçš„ channel å¤„ç†å™¨
        handler = self._channel_handlers.get(delivery.channel)
        if handler:
            try:
                await handler(delivery.to, delivery.text)
                return True
            except Exception as e:
                logger.error(f"æŠ•é€’å¤±è´¥: {e}")
                return False
        return False
```

---

### 3.3 Session Store é‡æ„

#### 3.3.1 ä¸ claw0 å…¼å®¹çš„ JSONL æ ¼å¼

```python
# src/chat/session_store.py

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Iterator
from dataclasses import dataclass, asdict

logger = logging.getLogger("chat.session")


@dataclass
class Session:
    """
    ä¼šè¯å¯¹è±¡

    ä¸ claw0 å…¼å®¹çš„ session_key æ ¼å¼:
    - agent:<agent_id>:main                    (æ‰€æœ‰DMå…±ç”¨)
    - agent:<agent_id>:direct:<peer_id>        (æ¯ä¸ªå‘é€è€…ç‹¬ç«‹)
    - agent:<agent_id>:<channel>:direct:<peer_id> (æŒ‰é€šé“éš”ç¦»)
    """

    session_key: str
    agent_id: str
    channel: str
    peer_id: str
    messages: list[dict] = None
    created_at: str = ""
    updated_at: str = ""

    def __post_init__(self):
        if self.messages is None:
            self.messages = []
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.updated_at:
            self.updated_at = self.created_at

    def add_message(self, role: str, content: str, metadata: dict = None):
        """æ·»åŠ æ¶ˆæ¯"""
        message = {
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat(),
        }
        if metadata:
            message["metadata"] = metadata
        self.messages.append(message)
        self.updated_at = datetime.now().isoformat()

    def to_dict(self) -> dict:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: dict) -> "Session":
        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})


class SessionStore:
    """
    JSONL æ ¼å¼çš„ä¼šè¯å­˜å‚¨

    æ–‡ä»¶ç»“æ„:
    data/sessions/
    â”œâ”€â”€ sessions.jsonl      # æ´»è·ƒä¼šè¯ (æœ€è¿‘30å¤©)
    â”œâ”€â”€ archive/            # å½’æ¡£ä¼šè¯
    â””â”€â”€ transcripts/        # å®Œæ•´å¯¹è¯è®°å½• (æŒ‰ä¼šè¯ID)
        â”œâ”€â”€ session-001.jsonl
        â””â”€â”€ session-002.jsonl
    """

    def __init__(self, base_dir: str = "./data/sessions"):
        self.base_dir = Path(base_dir)
        self.base_dir.mkdir(parents=True, exist_ok=True)
        self.archive_dir = self.base_dir / "archive"
        self.archive_dir.mkdir(exist_ok=True)
        self.transcript_dir = self.base_dir / "transcripts"
        self.transcript_dir.mkdir(exist_ok=True)

        self._sessions: dict[str, Session] = {}
        self._load_sessions()

    def _load_sessions(self):
        """ä» JSONL åŠ è½½ä¼šè¯"""
        sessions_file = self.base_dir / "sessions.jsonl"
        if not sessions_file.exists():
            return

        try:
            with open(sessions_file, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                    data = json.loads(line)
                    session = Session.from_dict(data)
                    self._sessions[session.session_key] = session
            logger.info(f"å·²åŠ è½½ {len(self._sessions)} ä¸ªä¼šè¯")
        except Exception as e:
            logger.error(f"åŠ è½½ä¼šè¯å¤±è´¥: {e}")

    def _save_sessions(self):
        """ä¿å­˜ä¼šè¯åˆ° JSONL"""
        sessions_file = self.base_dir / "sessions.jsonl"
        try:
            with open(sessions_file, "w", encoding="utf-8") as f:
                for session in self._sessions.values():
                    f.write(json.dumps(session.to_dict(), ensure_ascii=False) + "\n")
        except Exception as e:
            logger.error(f"ä¿å­˜ä¼šè¯å¤±è´¥: {e}")

    def _save_transcript(self, session: Session):
        """ä¿å­˜å®Œæ•´å¯¹è¯è®°å½•"""
        # ç”Ÿæˆå®‰å…¨çš„æ–‡ä»¶å
        safe_key = session.session_key.replace(":", "_")
        transcript_file = self.transcript_dir / f"{safe_key}.jsonl"

        try:
            with open(transcript_file, "a", encoding="utf-8") as f:
                for msg in session.messages:
                    f.write(json.dumps(msg, ensure_ascii=False) + "\n")
            # æ¸…ç©ºå·²ä¿å­˜çš„æ¶ˆæ¯
            session.messages = []
        except Exception as e:
            logger.error(f"ä¿å­˜å¯¹è¯è®°å½•å¤±è´¥: {e}")

    def get_or_create(
        self,
        session_key: str,
        agent_id: str = "main",
        channel: str = "cli",
        peer_id: str = "user",
    ) -> Session:
        """è·å–æˆ–åˆ›å»ºä¼šè¯"""
        if session_key in self._sessions:
            return self._sessions[session_key]

        session = Session(
            session_key=session_key,
            agent_id=agent_id,
            channel=channel,
            peer_id=peer_id,
        )
        self._sessions[session_key] = session
        return session

    def get(self, session_key: str) -> Session | None:
        """è·å–ä¼šè¯"""
        return self._sessions.get(session_key)

    def save(self, session: Session):
        """ä¿å­˜ä¼šè¯"""
        self._sessions[session.session_key] = session
        self._save_sessions()
        # åŒæ—¶ä¿å­˜å¯¹è¯è®°å½•
        self._save_transcript(session)

    def list_sessions(self, agent_id: str | None = None) -> list[Session]:
        """åˆ—å‡ºä¼šè¯"""
        sessions = list(self._sessions.values())
        if agent_id:
            sessions = [s for s in sessions if s.agent_id == agent_id]
        return sorted(sessions, key=lambda s: s.updated_at, reverse=True)

    def delete(self, session_key: str):
        """åˆ é™¤ä¼šè¯"""
        if session_key in self._sessions:
            del self._sessions[session_key]
            self._save_sessions()

    def archive_old_sessions(self, days: int = 30):
        """å½’æ¡£æ—§ä¼šè¯"""
        cutoff = datetime.now().timestamp() - (days * 24 * 3600)
        to_archive = []

        for key, session in list(self._sessions.items()):
            updated = datetime.fromisoformat(session.updated_at).timestamp()
            if updated < cutoff:
                to_archive.append((key, session))

        for key, session in to_archive:
            archive_file = self.archive_dir / f"{session.session_key.replace(':', '_')}.json"
            with open(archive_file, "w", encoding="utf-8") as f:
                json.dump(session.to_dict(), f, ensure_ascii=False)
            del self._sessions[key]

        if to_archive:
            self._save_sessions()
            logger.info(f"å½’æ¡£äº† {len(to_archive)} ä¸ªæ—§ä¼šè¯")

    def iter_sessions(self) -> Iterator[Session]:
        """è¿­ä»£æ‰€æœ‰ä¼šè¯"""
        yield from self._sessions.values()
```

---

### 3.4 Heartbeat å¢å¼ºè®¾è®¡

#### 3.4.1 OpenClaw 6æ­¥æ£€æŸ¥é“¾å®ç°

```python
# src/agent/heartbeat.py

import asyncio
import hashlib
import logging
import time
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Callable

logger = logging.getLogger("agent.heartbeat")


@dataclass
class HeartbeatConfig:
    """Heartbeat é…ç½®"""

    enabled: bool = True
    interval_seconds: int = 3600  # é»˜è®¤1å°æ—¶
    active_start_hour: int = 8    # æ´»è·ƒæ—¶æ®µå¼€å§‹
    active_end_hour: int = 22     # æ´»è·ƒæ—¶æ®µç»“æŸ
    heartbeat_md_path: Path = Path("./config/HEARTBEAT.md")
    dedup_window_seconds: int = 86400  # 24å°æ—¶å»é‡


class HeartbeatRunner:
    """
    å¿ƒè·³è¿è¡Œå™¨ - å®ç° OpenClaw 6æ­¥æ£€æŸ¥é“¾

    ä¿è¯ Agent å…·å¤‡ä¸»åŠ¨è¡Œä¸ºèƒ½åŠ›ï¼ŒåŒæ—¶é¿å…æ‰“æ‰°ç”¨æˆ·
    """

    def __init__(
        self,
        config: HeartbeatConfig,
        agent,  # SupervisorAgent å®ä¾‹
        channel_check_fn: Callable[[], bool],  # æ£€æŸ¥é€šé“æ˜¯å¦ç©ºé—²
        agent_check_fn: Callable[[], bool],   # æ£€æŸ¥Agentæ˜¯å¦ç©ºé—²
        on_heartbeat: Callable[[str], None],   # å¿ƒè·³è§¦å‘å›è°ƒ
    ):
        self.config = config
        self.agent = agent
        self.channel_check_fn = channel_check_fn
        self.agent_check_fn = agent_check_fn
        self.on_heartbeat = on_heartbeat

        self._running = False
        self._task = None
        self._last_run_at = 0
        self._recent_hashes: dict[str, float] = {}  # å†…å®¹å»é‡ç¼“å­˜

    async def start(self):
        """å¯åŠ¨å¿ƒè·³"""
        if not self.config.enabled:
            logger.info("Heartbeat å·²ç¦ç”¨")
            return

        self._running = True
        self._task = asyncio.create_task(self._loop())
        logger.info(f"Heartbeat å¯åŠ¨ï¼Œé—´éš” {self.config.interval_seconds}s")

    async def stop(self):
        """åœæ­¢å¿ƒè·³"""
        self._running = False
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
        logger.info("Heartbeat åœæ­¢")

    async def _loop(self):
        """ä¸»å¾ªç¯"""
        while self._running:
            try:
                if self._should_run():
                    await self._run_heartbeat()
                    self._last_run_at = time.time()

                # æ¸…ç†è¿‡æœŸå»é‡è®°å½•
                self._cleanup_dedup_cache()

                await asyncio.sleep(60)  # æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
            except Exception as e:
                logger.error(f"Heartbeat å¾ªç¯é”™è¯¯: {e}")
                await asyncio.sleep(300)  # å‡ºé”™åç­‰å¾…5åˆ†é’Ÿ

    def _should_run(self) -> bool:
        """
        OpenClaw 6æ­¥æ£€æŸ¥é“¾
        """
        # [1] heartbeat æ˜¯å¦å¯ç”¨?
        if not self.config.enabled:
            return False
        logger.debug("[Heartbeat] Step 1: enabled = True")

        # [2] é—´éš”æ˜¯å¦å·²è¿‡?
        now = time.time()
        elapsed = now - self._last_run_at
        if elapsed < self.config.interval_seconds:
            logger.debug(f"[Heartbeat] Step 2: interval not passed ({elapsed:.0f}s < {self.config.interval_seconds}s)")
            return False
        logger.debug("[Heartbeat] Step 2: interval passed")

        # [3] æ˜¯å¦åœ¨æ´»è·ƒæ—¶æ®µ?
        current_hour = datetime.now().hour
        if not (self.config.active_start_hour <= current_hour < self.config.active_end_hour):
            logger.debug(f"[Heartbeat] Step 3: outside active hours ({current_hour})")
            return False
        logger.debug(f"[Heartbeat] Step 3: within active hours ({current_hour})")

        # [4] HEARTBEAT.md æ˜¯å¦å­˜åœ¨ä¸”æœ‰å†…å®¹?
        if not self.config.heartbeat_md_path.exists():
            logger.debug("[Heartbeat] Step 4: HEARTBEAT.md not found")
            return False

        content = self.config.heartbeat_md_path.read_text(encoding="utf-8").strip()
        if not content:
            logger.debug("[Heartbeat] Step 4: HEARTBEAT.md is empty")
            return False
        logger.debug("[Heartbeat] Step 4: HEARTBEAT.md exists and has content")

        # [5] ä¸»é€šé“æ˜¯å¦ç©ºé—²? (æ²¡æœ‰æ­£åœ¨å¤„ç†çš„ç”¨æˆ·æ¶ˆæ¯)
        if not self.channel_check_fn():
            logger.debug("[Heartbeat] Step 5: channel is busy")
            return False
        logger.debug("[Heartbeat] Step 5: channel is idle")

        # [6] agent å½“å‰æ˜¯å¦ç©ºé—²? (æ²¡æœ‰åœ¨è¿è¡Œä¸­)
        if not self.agent_check_fn():
            logger.debug("[Heartbeat] Step 6: agent is busy")
            return False
        logger.debug("[Heartbeat] Step 6: agent is idle")

        logger.info("[Heartbeat] All 6 checks passed, should run")
        return True

    async def _run_heartbeat(self):
        """æ‰§è¡Œå¿ƒè·³"""
        try:
            # è¯»å– HEARTBEAT.md
            heartbeat_content = self.config.heartbeat_md_path.read_text(encoding="utf-8")

            # æ„å»ºæç¤ºè¯
            prompt = f"""{heartbeat_content}

Current time: {datetime.now().isoformat()}

Please check the above items and respond with your findings.
If nothing needs attention, respond with exactly: HEARTBEAT_OK"""

            # è¿è¡Œ Agent
            response_parts = []
            async for output in self.agent.handle(prompt, session_id="heartbeat"):
                if isinstance(output, str):
                    response_parts.append(output)

            response = "".join(response_parts).strip()

            # æ£€æŸ¥æ˜¯å¦æ˜¯é™é»˜å“åº”
            if "HEARTBEAT_OK" in response:
                logger.debug("Heartbeat returned HEARTBEAT_OK, silent")
                return

            # æ£€æŸ¥æ˜¯å¦æ˜¯é‡å¤å†…å®¹
            if self._is_duplicate(response):
                logger.debug("Heartbeat response is duplicate, skipping")
                return

            # è§¦å‘å›è°ƒ
            logger.info("Heartbeat triggered proactive message")
            self.on_heartbeat(response)

        except Exception as e:
            logger.error(f"Heartbeat execution failed: {e}")

    def _is_duplicate(self, content: str) -> bool:
        """æ£€æŸ¥å†…å®¹æ˜¯å¦åœ¨24å°æ—¶å†…é‡å¤"""
        content_hash = hashlib.sha256(content.encode()).hexdigest()[:16]
        now = time.time()

        if content_hash in self._recent_hashes:
            last_time = self._recent_hashes[content_hash]
            if now - last_time < self.config.dedup_window_seconds:
                return True

        self._recent_hashes[content_hash] = now
        return False

    def _cleanup_dedup_cache(self):
        """æ¸…ç†è¿‡æœŸçš„å»é‡è®°å½•"""
        now = time.time()
        cutoff = now - self.config.dedup_window_seconds
        self._recent_hashes = {
            k: v for k, v in self._recent_hashes.items()
            if v > cutoff
        }
```

**HEARTBEAT.md ç¤ºä¾‹ï¼š**
```markdown
# Heartbeat Instructions

Check the following and report ONLY if action is needed:

1. Review today's tasks and identify any overdue items
2. Check for upcoming deadlines within the next 24 hours
3. Review the user's recent memories for any unresolved issues
4. Check if there are any reminders set for this time

If nothing needs attention, respond with exactly: HEARTBEAT_OK

If action is needed:
- Be concise and specific
- Suggest concrete next steps
- Use a friendly, proactive tone
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šå®æ–½è·¯çº¿å›¾

### 4.1 é˜¶æ®µä¸€ï¼šåŸºç¡€è®¾æ–½ï¼ˆ4å‘¨ï¼‰

#### Week 1-2: Gateway Server
- [ ] å®ç° WebSocket æœåŠ¡å™¨æ¡†æ¶
- [ ] å®ç° JSON-RPC 2.0 åè®®è§£æ
- [ ] å®ç°è®¤è¯ä¸­é—´ä»¶ (Bearer Token)
- [ ] å®ç°æ ¸å¿ƒæ–¹æ³• (chat.send, chat.history, health)
- [ ] é›†æˆåˆ° main.py å¯åŠ¨æµç¨‹

#### Week 3: Delivery Queue
- [ ] å®ç° QueuedDelivery æ•°æ®ç±»
- [ ] å®ç°åŸå­å†™å…¥æœºåˆ¶
- [ ] å®ç°é€€é¿é‡è¯•é€»è¾‘
- [ ] å®ç°åå°å·¥ä½œçº¿ç¨‹
- [ ] é›†æˆåˆ° Agent å“åº”æµç¨‹

#### Week 4: Session Store é‡æ„
- [ ] å®ç° Session æ•°æ®ç±»
- [ ] å®ç° JSONL è¯»å†™
- [ ] å®ç° claw0 å…¼å®¹çš„ session_key
- [ ] é‡æ„ ChatSession ä½¿ç”¨æ–°çš„ SessionStore
- [ ] å®ç°ä¼šè¯å½’æ¡£åŠŸèƒ½

### 4.2 é˜¶æ®µäºŒï¼šæ™ºèƒ½å¢å¼ºï¼ˆ2å‘¨ï¼‰

#### Week 5: Heartbeat å¢å¼º
- [ ] å®ç° HeartbeatConfig
- [ ] å®ç° 6æ­¥æ£€æŸ¥é“¾
- [ ] å®ç°äº’æ–¥é”æœºåˆ¶
- [ ] å®ç°24å°æ—¶å»é‡
- [ ] åˆ›å»º HEARTBEAT.md æ¨¡æ¿

#### Week 6: Message Routing (å¯é€‰)
- [ ] å®ç° Binding æ•°æ®ç±»
- [ ] å®ç°åŒ¹é…ç®—æ³•
- [ ] å®ç°å¤š Agent æ”¯æŒ
- [ ] é›†æˆåˆ° Gateway

### 4.3 é˜¶æ®µä¸‰ï¼šç”Ÿæ€æ‰©å±•ï¼ˆæŒç»­ï¼‰

- [ ] å®ç° Channel æŠ½è±¡æ¥å£
- [ ] å®ç° TelegramChannel
- [ ] å®ç° DiscordChannel
- [ ] å®ç° WebhookChannel

---

## ç¬¬äº”éƒ¨åˆ†ï¼šé£é™©è¯„ä¼°ä¸ç¼“è§£

| é£é™© | å¯èƒ½æ€§ | å½±å“ | ç¼“è§£æªæ–½ |
|------|--------|------|----------|
| Gateway å¼•å…¥å®‰å…¨æ¼æ´ | ä¸­ | é«˜ | å¼ºåˆ¶è®¤è¯ã€è¾“å…¥éªŒè¯ã€é€Ÿç‡é™åˆ¶ |
| Delivery Queue ç£ç›˜IOæ€§èƒ½ç“¶é¢ˆ | ä¸­ | ä¸­ | æ‰¹é‡å¤„ç†ã€å¼‚æ­¥å†™å…¥ã€å®šæœŸå½’æ¡£ |
| Session Store æ•°æ®ä¸¢å¤± | ä½ | é«˜ | åŸå­å†™å…¥ã€å®šæœŸå¤‡ä»½ã€WALæ—¥å¿— |
| Heartbeat æ‰“æ‰°ç”¨æˆ· | ä¸­ | ä¸­ | 6æ­¥æ£€æŸ¥é“¾ã€å»é‡æœºåˆ¶ã€æ´»è·ƒæ—¶æ®µ |
| é‡æ„å¼•å…¥å›å½’Bug | ä¸­ | ä¸­ | å®Œæ•´æµ‹è¯•ã€ç°åº¦å‘å¸ƒã€å¿«é€Ÿå›æ»š |

---

## ç¬¬å…­éƒ¨åˆ†ï¼šæˆåŠŸæŒ‡æ ‡

### 6.1 æŠ€æœ¯æŒ‡æ ‡
- [ ] Gateway Server æ”¯æŒ 100+ å¹¶å‘è¿æ¥
- [ ] Delivery Queue ä¿è¯ 99.9% æ¶ˆæ¯ä¸ä¸¢å¤±
- [ ] Session Store æ”¯æŒ 1000+ ä¼šè¯
- [ ] Heartbeat è¯¯è§¦å‘ç‡ < 1%

### 6.2 ä½“éªŒæŒ‡æ ‡
- [ ] ç³»ç»Ÿé‡å¯åå¯¹è¯å†å²å®Œæ•´æ¢å¤
- [ ] ç½‘ç»œä¸­æ–­åæ¶ˆæ¯è‡ªåŠ¨é‡å‘
- [ ] Agent èƒ½ä¸»åŠ¨æé†’é‡è¦äº‹é¡¹
- [ ] æ”¯æŒå¤šå®¢æˆ·ç«¯åŒæ—¶æ¥å…¥

---

## é™„å½•ï¼šå‚è€ƒèµ„æº

- claw0 é¡¹ç›®: https://github.com/shareAI-lab/claw0
- OpenClaw é¡¹ç›®: https://github.com/openclaw/openclaw
- JSON-RPC 2.0 è§„èŒƒ: https://www.jsonrpc.org/specification
- WebSocket åè®®: https://tools.ietf.org/html/rfc6455

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2026-02-24
**ä½œè€…**: AI Assistant